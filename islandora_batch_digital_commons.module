<?php

/**
 * @file
 * Module for Batch ingests.
 */
define('ISLANDORA_BATCH_DIGITAL_COMMONS_DELIMITER',',');
define('ISLANDORA_BATCH_DIGITAL_COMMONS_ENCLOSURE','"');
define('ISLANDORA_BATCH_DIGITAL_COMMONS_ESCAPE','"');
define('DIGITAL_COMMONS_MAX_SUBDIRECTORY_DEPTH_FOR_COLLECTIONS', '10');

/**
 * Function to handle preprocessing.
 */
function islandora_batch_digital_commons_handle_preprocessor($preprocessor) {
  return $preprocessor->preprocess();
}

/**
 * Generate and set the batch operations.
 *
 * After calling this, it will be necessary to call one of the functions which
 * actually execute the batch, such as batch_process(),
 * drush_backend_batch_process() or background_batch_process_batch().
 *
 * Queries the database for preprocessed entries, and attempts to ingest them.
 */
function islandora_batch_digital_commons_set_operations($parameters) {
  $batch = array(
    'title' => t('Islandora Batch Ingest Digital Commons'),
    'finished' => 'islandora_batch_finished',
    'init_message' => t('Initializing...'),
    'file' => drupal_get_path('module', 'islandora_batch_digital_commons') . '/includes/ingest_digital_commons.batch.inc',
    'operations' => array(),
    'progress_message' => t('Time elapsed: @elapsed.'),
  );

  if (isset($parameters['preprocessor'])) {
    $batch['operations'][] = array('islandora_batch_digital_commons_ingest_preprocess', array($parameters['preprocessor']));
  }
  if (isset($parameters['preprocessor']) || isset($parameters['ingest_set'])) {
    $batch['progress_message'] = t('Time elapsed: @elapsed <br/>Estimated time remaining @estimate.');
  }

  $batch['operations'][] = array('islandora_batch_digital_commons_ingest_process', array($parameters));

  batch_set($batch);
}

/**
 * Dumbly sets the batch operations and calls batch_process().
 */
function islandora_batch_digital_commons_ingest($parameters) {
  islandora_batch_set_operations($parameters);
  batch_process();
}

/**
 * This should really be a callout to the code in Islandora Ingest Collections
 * But it seems kind of odd to keep a dependency to that code here, why
 * should they be tied together?
 * 
 * Retrieve data from a delimiter-separated values file
 * The defaults assume a comma separated values file
 *
 * The DSV file must have the following columns:
 *   -title
 *   -cdm_alias (Text/Text field)
 *   -description (Long text/Textarea (multiple rows))
 *   -thumbnail (Image/Image)
 *   -object_id (Text/Text field)
 *
 * @param string $data_file_path
 *   The absolute filesystem path to the comma-separated-value file 
 * @param string $delimiter_char
 *   The optional delimiter parameter sets the field delimiter (one character only)
 *   Default is the ',' char, separates one data cell from another
 * @param string $enclosure_char
 *   The optional enclosure parameter sets the field enclosure character (one character only).
 *   The Default is '"' char, encapsulates the data cell data
 * @param string $escape_char
 *   The optional escape parameter sets the escape character (one character only). 
 *   The Default is '"', provides use of enclosure char with in data cell data
 * 
 */
function retrieveDataFromDsvFile($data_file_path, $delimiter_char = ISLANDORA_BATCH_DIGITAL_COMMONS_DELIMITER, 
            $enclosure_char = ISLANDORA_BATCH_DIGITAL_COMMONS_ENCLOSURE, $escape_char = ISLANDORA_BATCH_DIGITAL_COMMONS_ESCAPE) {
    $dsv_data = array();
    if (($data_file_handle = fopen($data_file_path, "r")) !== FALSE) {
        while (($dsv_row = fgetcsv($data_file_handle, 0, $delimiter_char,
                $enclosure_char,$escape_char)) !== FALSE) {
            $collection_data = new stdClass();
            $collection_data->digitalCommonsSeries = strtolower($dsv_row[0]);
            $collection_data->parent = strtolower($dsv_row[1]);
            $collection_data->namespace = strtolower($dsv_row[2]);
            $collection_data->objectId = $dsv_row[3];
            $collection_data->pid = $collection_data->namespace . ':' . $collection_data->objectId;
            $dsv_data[] = $collection_data;
        }
    } else {
        throw new Exception("Unable to open $data_file_path");
    }
    return $dsv_data;
}
function islandora_batch_digital_commons_islandora_batch_object_processed(AbstractFedoraObject $ingest_object, $is_object_state_done)
{
    if ($is_object_state_done) {
        $key = IslandoraScanBatchObjectDigitalCommons::$BATCH_OBJECT_PREFIX . $ingest_object->id;
        $cached_object = cache_get($key, 'cache_field');
        $islandoraScanBatchObjectDigitalCommons = $cached_object->data;

        if (isset($islandoraScanBatchObjectDigitalCommons) && is_a($islandoraScanBatchObjectDigitalCommons, 'IslandoraScanBatchObjectDigitalCommons')) {
            # determine if the object needs to be embargoed or withdrawn

            $object_info = $islandoraScanBatchObjectDigitalCommons->getObjectInfo();
            $is_object_withdrawn = false;
            $digital_commons_metadata_xml = $object_info->getDigitalCommonsMetadata();
            $digital_commons_metadata_domDocument = new DOMDocument();
            $digital_commons_metadata_domDocument->loadXML($digital_commons_metadata_xml);
            $digital_commons_metadata_xpath = new DOMXPath($digital_commons_metadata_domDocument);
            // Withdrawn
            $digital_commons_metadata_withdrawn_datestr = $digital_commons_metadata_xpath->evaluate('string(//documents/document/withdrawn)');

            if (! empty($digital_commons_metadata_withdrawn_datestr)) {

                $is_object_withdrawn = true;
                // embargo the entire object
                islandora_scholar_embargo_set_embargo($ingest_object);

            }

            if (! $is_object_withdrawn) {
                // Embargo
                $digital_commons_metadata_embargo_datestr = $digital_commons_metadata_xpath->evaluate('string(//documents/document/fields/field[@name="embargo_date"]/value)');
                if (isset($digital_commons_metadata_embargo_datestr)) {

                    $digital_commons_metadata_embargo_timestamp = strtotime($digital_commons_metadata_embargo_datestr);
                    if (isset($digital_commons_metadata_embargo_timestamp)) {
                        $currentTime = time();

                        if ($digital_commons_metadata_embargo_timestamp > $currentTime) {
                            $datastreams = $islandoraScanBatchObjectDigitalCommons->correlateModelEmbargoDatastreams();
                            // needs xsd:dateTime string -- CCYY-MM-DDThh:mm:ss[Z|(+|-)hh:mm]
                            //embargo the datastreams for the object
                            $digital_commons_metadata_embargo_date = date( 'c', $digital_commons_metadata_embargo_timestamp);
                            if ((sizeof($datastreams) > 0) && isset($digital_commons_metadata_embargo_date)) {
                                islandora_scholar_embargo_set_embargo($ingest_object, $datastreams,$digital_commons_metadata_embargo_date );
                            }
                        }

                    }
                }
            }
            # determine if the object needs revisions added to the main datastream (what is the main datastream ?)
            $correlations = $islandoraScanBatchObjectDigitalCommons->correlateModelDatastreams();


            foreach ($correlations as $correlation) {
                # retrieve any matching patterns that can be applied to files
                foreach ($correlation as $key => $value) {
                    $returnDatastream = $ingest_object->repository->api->m->getDatastream($ingest_object->id, $key);
                    $datastreamCreatedTimestamp = strtotime($returnDatastream['dsCreateDate']);
                    $responses = array();
                    $revisionsFileList = $islandoraScanBatchObjectDigitalCommons->findRevisionFiles($value);

                    if (isset($revisionsFileList)) {
                        $responses[] = islandora_batch_digital_commons_apply_revisions($ingest_object, $key, $revisionsFileList);
                    }
                    if (sizeof($responses) > 0) {
                        // make the original the top revision again
                        $modifyDatastreamArgs = array('dsFile' => $islandoraScanBatchObjectDigitalCommons->getURIforLabel($key));
                        $ingest_object->repository->api->m->modifyDatastream($ingest_object->id, $key, $modifyDatastreamArgs);
                        $purgeDatastreamArgs = array('startDT' => $returnDatastream['dsCreateDate'] , 'endDT' => $returnDatastream['dsCreateDate'] , 'logMessage' => "delete the replaced original");
                        $return = $ingest_object->repository->api->m->purgeDatastream($ingest_object->id, $key,$purgeDatastreamArgs);

                    }
                }
            }

        } else {
            new Exception("Unable to retrieve cache for the object " . $ingest_object->id . "! Unable to determine revision history and embargo");
        }

    }
}
function islandora_batch_digital_commons_apply_revisions($ingest_object, $key, $revisionsFileList) {
    $responseList = array();
    foreach ($revisionsFileList as $revisionFile) {
        $modifyDatastreamArgs = array('dsFile' => $revisionFile);
        $response = $ingest_object->repository->api->m->modifyDatastream($ingest_object->id, $key, $modifyDatastreamArgs);
        if (isset($response)) {
            $responseList[] = $response;
        }
    }
    return $responseList;
}

function islandora_batch_digital_commons__printWarningMessage($comment ) {
    $message = t(date(DATE_ATOM) . "  " . $comment);
    \drupal_set_message($comment, 'warning');
    \watchdog('islandora_scan_batch_ditigal_commons', $comment, null, WATCHDOG_WARNING);
}
